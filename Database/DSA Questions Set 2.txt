1. What does Big-O notation represent?
A. Best case complexity
B. Average case complexity
C. Upper bound of algorithm complexity
D. Exact execution time

Correct Answer: C
Explanation:
Big-O notation describes the worst-case (upper bound) growth rate of time or space as input size increases.
It ignores constants and lower-order terms.

2. Time complexity of nested loops each running n times is:
A. O(n)
B. O(log n)
C. O(n²)
D. O(2n)

Correct Answer: C
Explanation:
Two nested loops each running n times result in n × n = n² operations.
for(int i=0;i<n;i++){
    for(int j=0;j<n;j++){
        System.out.println(i+j);
    }
}

3. Which complexity is considered most efficient for searching?
A. O(n)
B. O(n log n)
C. O(log n)
D. O(1)

Correct Answer: D
Explanation:
O(1) means constant time, achieved by hashing (e.g., HashMap).

4. What is the space complexity of recursion mainly due to?
A. Heap memory
B. Global variables
C. Stack frames
D. CPU registers

Correct Answer: C
Explanation:
Each recursive call uses stack memory for local variables and return addresses.

5. Which algorithm has exponential time complexity?
A. Binary Search
B. Merge Sort
C. Recursive Fibonacci
D. Heap Sort

Correct Answer: C
Explanation:
Naive recursive Fibonacci recalculates values repeatedly → O(2ⁿ) complexity.

6. What is the best case time complexity of linear search?
A. O(n)
B. O(log n)
C. O(1)
D. O(n²)

Correct Answer: C
Explanation:
If the element is found at the first position, linear search takes constant time.

7. Worst case time complexity of linear search?
A. O(1)
B. O(log n)
C. O(n)
D. O(n²)

Correct Answer: C
Explanation:
If element is at last position or absent, all n elements are checked.

8. Time complexity of accessing an element in an array using index?
A. O(n)
B. O(log n)
C. O(1)
D. O(n log n)

Correct Answer: C
Explanation:
Arrays provide direct (random) access using index.

9. Time complexity of insertion at end of ArrayList (average case)?
A. O(1)
B. O(log n)
C. O(n)
D. O(n²)

Correct Answer: A
Explanation:
ArrayList inserts at end in amortized constant time, resizing happens occasionally.

10. Time complexity of inserting at beginning of ArrayList?
A. O(1)
B. O(log n)
C. O(n)
D. O(n log n)

Correct Answer: C
Explanation:
All elements must be shifted → linear time.

11. Which interface is the root of Java Collection hierarchy?
A. List
B. Set
C. Collection
D. Iterable

Correct Answer: C
Explanation:
Collection is the root interface for List, Set, and Queue.

12. Which collection allows duplicate elements?

A. Set
B. HashSet
C. TreeSet
D. List

Correct Answer: D
Explanation:
List allows duplicate values and maintains insertion order.

13. Which collection does NOT allow duplicates?

A. ArrayList
B. LinkedList
C. HashSet
D. Vector

Correct Answer: C
Explanation:
HashSet stores unique elements only.

14. Average time complexity of search in HashMap?

A. O(n)
B. O(log n)
C. O(1)
D. O(n log n)

Correct Answer: C
Explanation:
HashMap uses hashing → constant time average operations.

15. Worst case time complexity of HashMap operations?
A. O(1)
B. O(log n)
C. O(n)
D. O(n²)

Correct Answer: C
Explanation:
In case of many collisions, HashMap degrades to linear search.

16. Which collection maintains elements in sorted order?

A. HashSet
B. LinkedHashSet
C. TreeSet
D. ArrayList

Correct Answer: C
Explanation:
TreeSet uses Red-Black Tree and maintains sorted order.

17. Time complexity of TreeSet insertion?
A. O(1)
B. O(log n)
C. O(n)
D. O(n²)

Correct Answer: B
Explanation:
TreeSet is implemented using balanced BST, height = log n.

18. Which Map implementation maintains insertion order?
A. HashMap
B. TreeMap
C. LinkedHashMap
D. Hashtable

Correct Answer: C
Explanation:
LinkedHashMap maintains insertion order using a doubly linked list.

19. Which Map maintains keys in sorted order?
A. HashMap
B. TreeMap
C. LinkedHashMap
D. ConcurrentHashMap

Correct Answer: B
Explanation:
TreeMap stores keys in sorted order using Red-Black Tree.

20. Time complexity of TreeMap get() operation?
A. O(1)
B. O(log n)
C. O(n)
D. O(n log n)

Correct Answer: B
Explanation:
TreeMap operations depend on tree height → log n.

21. Which collection is thread-safe?
A. ArrayList
B. HashMap
C. Vector
D. HashSet

Correct Answer: C
Explanation:
Vector methods are synchronized → thread-safe but slower.

22. Which collection is best for frequent insertions & deletions?
A. ArrayList
B. LinkedList
C. Vector
D. TreeSet

Correct Answer: B
Explanation:
LinkedList does not require shifting → efficient insert/delete.

23. Time complexity of remove() in LinkedList (at known position)?
A. O(1)
B. O(log n)
C. O(n)
D. O(n²)

Correct Answer: A
Explanation:
Once the node is reached, removal is done by pointer adjustment.

24. Which interface allows only one end insertion & deletion?
A. List
B. Set
C. Queue
D. Map

Correct Answer: C
Explanation:
Queue follows FIFO, insertion at rear and deletion at front.

25. Time complexity of push and pop in Stack?
A. O(n)
B. O(log n)
C. O(1)
D. O(n log n)

Correct Answer: C
Explanation:
Stack operations are performed at one end only, constant time.

26. Which collection uses hashing internally?
A. TreeSet
B. HashSet
C. LinkedList
D. Vector

Correct Answer: B
Explanation:
HashSet uses HashMap internally to store elements.

27. Which collection allows null keys?
A. TreeMap
B. Hashtable
C. HashMap
D. ConcurrentHashMap

Correct Answer: C
Explanation:
HashMap allows one null key and multiple null values.

28. Time complexity of Collections.sort() internally uses?
A. Bubble Sort
B. Selection Sort
C. Tim Sort
D. Heap Sort

Correct Answer: C
Explanation:
Java uses TimSort (hybrid of merge + insertion sort).

29. Which collection is best for fast lookup operations?
A. ArrayList
B. LinkedList
C. HashMap
D. TreeMap

Correct Answer: C
Explanation:
HashMap provides O(1) average lookup time.

30. Which complexity grows slowest as input increases?
A. O(n)
B. O(n log n)
C. O(log n)
D. O(n²)

Correct Answer: C
Explanation:
Logarithmic growth increases very slowly → highly efficient.

31. What is the time complexity of contains() method in HashSet (average case)?
A. O(n)
B. O(log n)
C. O(1)
D. O(n log n)

Correct Answer: C. O(1)
Explanation:
HashSet uses hashing internally.
In the average case, contains() computes the hash and directly checks the bucket, resulting in constant time complexity.

32. What is the worst-case time complexity of contains() in HashSet?
A. O(1)
B. O(log n)
C. O(n)
D. O(n²)

Correct Answer: C. O(n)
Explanation:
In the worst case, when many elements collide into the same bucket, HashSet must traverse all elements in that bucket → linear time.

33. What is the time complexity of add() operation in LinkedList?
A. O(1)
B. O(log n)
C. O(n)
D. O(n²)

Correct Answer: A. O(1)
Explanation:
Insertion at the beginning or end of a LinkedList is done by adjusting pointers only, requiring constant time.

34. Which collection provides O(log n) time complexity for insertion, deletion, and search?
A. HashSet
B. ArrayList
C. TreeSet
D. LinkedList

Correct Answer: C. TreeSet
Explanation:
TreeSet is implemented using a Red-Black Tree (self-balancing BST), where all major operations take O(log n) time.

35. Time complexity of remove(Object o) in ArrayList (worst case)?
A. O(1)
B. O(log n)
C. O(n)
D. O(n log n)

Correct Answer: C. O(n)
Explanation:
After removal, all subsequent elements must be shifted left, resulting in linear time complexity.

36. What is the space complexity of an algorithm using recursion depth n?
A. O(1)
B. O(log n)
C. O(n)
D. O(n²)

Correct Answer: C. O(n)
Explanation:
Each recursive call consumes one stack frame.
If recursion depth is n, stack space required is O(n).

37. Which Java collection gives the fastest iteration performance?
A. LinkedList
B. Vector
C. ArrayList
D. TreeSet

Correct Answer: C. ArrayList
Explanation:
ArrayList stores elements in contiguous memory, making iteration cache-friendly and faster than linked structures.

38. What is the time complexity of get(index) in LinkedList?
A. O(1)
B. O(log n)
C. O(n)
D. O(n log n)

Correct Answer: C. O(n)
Explanation:
LinkedList does not support random access.
To access an element by index, it must traverse from the beginning or end → linear time.

39. Which collection is best when both fast search and insertion order are required?
A. HashSet
B. TreeSet
C. LinkedHashSet
D. ArrayList

Correct Answer: C. LinkedHashSet
Explanation:
LinkedHashSet:
Uses hashing → fast search (O(1) average)
Maintains insertion order using a linked list

40. Which complexity represents an algorithm whose performance doubles when input doubles?
A. O(log n)
B. O(n)
C. O(n log n)
D. O(n²)

Correct Answer: B. O(n)
Explanation:
In linear complexity, if input size doubles, execution time also roughly doubles, which is typical for simple loops.